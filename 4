#include "../include/lexer.h"

class Terminal {};

class Nonterminal {};

class Expression {
  int value;
  std::vector<Expression> expressions;
};

class Statement {
  // contains return and an Expression
  TokenType left = TokenType::RETURN;
  TokenType right = TokenType::SEMICOLON;
  Expression expr;
};

class Function {
  TokenType returnValue = TokenType::INT;
  std::string identifier;
  TokenType open = TokenType::LEFT_BRACKET;
  Statement statement;
  TokenType closing = TokenType::RIGHT_BRACKET;
};

class Program {
  Function function;
};

// idea you look for program first then you parse till you startt a function ->
// does the function follow the grammar rules? Parser needs to be able to check
// the grammar rules
//
//
// a grammar element needs a few porperies to cover all eventuallites
//
// extendable ->

class Grammar {
public:
  std::vector<TokenType> syntax;

  Grammar(std::vector<TokenType> &syntax) : syntax(syntax) {}

  bool evaluate(std::vector<Token> sentence) {

    for (int i = 0; i < syntax.size(); i++) {

      if (sentence[i].getToken() != syntax[i]) {
        return false;
      }
    }
  }
};

class Parser {

  void parse(std::vector<Token> tokens) {}

  bool evaluate()
};
